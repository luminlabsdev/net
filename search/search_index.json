{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A simple and efficient networking library.</p> <p>Guides Reference</p>"},{"location":"#better-api","title":"Better API","text":"<pre><code>local Net = require(Packages.net).Client\nlocal MyEvent = Net.Event(\"MyEvent\")\n\nMyEvent:Fire(\"Hello server\")\nMyEvent:Listen(function()\n    print(\"Listening to the server!\")\nend)\n</code></pre> <p>Has some of the best API out all of the non-buffer networking libraries available, with no caveats.</p>"},{"location":"#easy-type-validation","title":"Easy Type Validation","text":"<pre><code>local Net = require(Packages.net).Server\nlocal MyEvent = Net.Event(\"MyEvent\", true, {\"number\", \"string\", \"boolean\"})\n\nMyEvent:Listen(function(number, string, boolean)\n    print(\"Only accepting numbers, strings, and bools in this order\")\nend) -- If the client does not send these types in that order, the packet will be dropped\n</code></pre> <p>Provides better type validation API than other libraries like Red, which require lots of extra code.</p>"},{"location":"#simple-middleware","title":"Simple Middleware","text":"<pre><code>local Net = require(Packages.net).Server\nlocal MyEvent = Net.Event(\"MyEvent\", true, {\"number\", \"string\", \"boolean\"})\n\nMyEvent:SetMiddleware({\n    Dropped = function(value1, value2, value3) -- got string, boolean, number\n        print(\"Packet dropped!\") -- Net will drop the packet, but this allows for a custom callback\n    end\n})\n\nMyEvent:Listen(function(number, string, boolean)\n    print(\"Only accepting numbers, strings, and bools in this order\")\nend)\n</code></pre> <p>Has a great middleware API which makes some of the internal code extendable, and allow it to do more.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>hide:</p> <ul> <li>navigation</li> </ul>"},{"location":"changelog/#changelog","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#050-2024-10-11","title":"0.5.0 - 2024-10-11","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Adds a middleware API in place of callbacks</li> <li>Packet is now dropped if args contain <code>NaN</code></li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Changes <code>Functions</code> to <code>Async</code></li> <li>Moves <code>Listen</code> &amp; <code>OnRequest</code> type validation params to constructor</li> <li>Changes <code>OnInvoke</code> and <code>InvokeAsync</code> to <code>OnRequest</code> and <code>Request</code></li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removes default ratelimiting in favor of a custom middleware-based solution</li> </ul>"},{"location":"changelog/#041-2024-09-19","title":"0.4.1 - 2024-09-19","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fixed an issue where <code>Futures</code> were still used that resulted in errornous code</li> </ul>"},{"location":"changelog/#040-2024-09-18","title":"0.4.0 - 2024-09-18","text":""},{"location":"changelog/#removed_1","title":"Removed","text":"<ul> <li>Removed <code>Futures</code>, all code now yields</li> </ul>"},{"location":"changelog/#030-2024-09-08","title":"0.3.0 - 2024-09-08","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fixed issues with wally package types</li> <li>Fixed changelog problems</li> </ul>"},{"location":"changelog/#020-2024-09-08","title":"0.2.0 - 2024-09-08","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added proper docs</li> <li>Futures in replacement of Promises</li> </ul>"},{"location":"changelog/#010-2024-08-06","title":"0.1.0 - 2024-08-06","text":"<p>Initial release! \ud83e\udd73</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#roblox","title":"Roblox","text":"<ol> <li>Go to the latest releases page</li> <li>Download <code>Standalone.rbxm</code></li> <li>Select <code>Insert from file</code>, and find <code>Standalone.rbxm</code> in your designated downloads folder</li> </ol>"},{"location":"installation/#wally","title":"Wally","text":"<ol> <li>Open a project in your favorite text editor</li> <li>Add <code>lumin/net@^0.4.0</code> to your <code>wally.toml</code> file</li> <li>Run <code>wally install</code> the project should be inside of your <code>/Packages</code> directory.</li> </ol>"},{"location":"api/","title":"LuminNet","text":"<p>The main class of LuminNet.</p>"},{"location":"api/#properties","title":"Properties","text":""},{"location":"api/#client","title":"<code>Client</code>","text":"<p>A reference that points to the client sided version of the library</p> <ul> <li>Client</li> </ul>"},{"location":"api/#server","title":"<code>Server</code>","text":"<p>A reference that points to the server sided version of the library</p> <ul> <li>Server</li> </ul>"},{"location":"api/client/","title":"Interface","text":"<p>References the client event and function constructors</p>"},{"location":"api/client/#functions","title":"Functions","text":""},{"location":"api/client/#event","title":"<code>Event</code>","text":"<p>Creates a new remote event</p> <p>Parameters</p> <ul> <li> <p>name: <code>string</code> The name of the remote event to reference or create</p> </li> <li> <p>reliable: <code>boolean</code> Whether the remote event should be reliable or not. Defaults to true</p> </li> </ul> <p>Returns</p> <ul> <li>Event</li> </ul>"},{"location":"api/client/#function","title":"<code>Function</code>","text":"<p>Creates a new remote function</p> <p>Parameters</p> <ul> <li> <p>name: <code>string</code> The name of the remote function to reference or create</p> </li> <li> <p>reliable: <code>boolean</code> Whether the remote function should be reliable or not. Defaults to true This currently has no effect on remote functions</p> </li> </ul> <p>Returns</p> <ul> <li>Function</li> </ul>"},{"location":"api/client/async/","title":"Async","text":"<p>A client-sided async.</p>"},{"location":"api/client/async/#properties","title":"Properties","text":""},{"location":"api/client/async/#reliable","title":"<code>Reliable</code>","text":"<p>Whether or not the async uses a reliable remote event.</p> <ul> <li>boolean</li> </ul>"},{"location":"api/client/async/#methods","title":"Methods","text":""},{"location":"api/client/async/#request","title":"<code>Request</code>","text":"<p>Requests data the server, equivalent to RemoteFunction:InvokeServer. Returns a Future.</p> <p>Parameters</p> <ul> <li>data: <code>...any</code> The data to request the server with</li> </ul> <p>Returns</p> <ul> <li>...any</li> </ul>"},{"location":"api/client/event/","title":"Event","text":"<p>A client-sided event.</p>"},{"location":"api/client/event/#properties","title":"Properties","text":""},{"location":"api/client/event/#reliable","title":"<code>Reliable</code>","text":"<p>Whether or not the event uses a reliable remote event.</p> <ul> <li>boolean</li> </ul>"},{"location":"api/client/event/#methods","title":"Methods","text":""},{"location":"api/client/event/#fire","title":"<code>Fire</code>","text":"<p>Fires an event which sends data to the server, equivalent to RemoteEvent:FireServer.</p> <p>Parameters</p> <ul> <li>data: <code>...any</code> The data that should be sent to the server</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/client/event/#firenow","title":"<code>FireNow</code>","text":"<p>Same as <code>Fire</code> but does not batch the call / wait until the next frame.</p> <p>Parameters</p> <ul> <li>data: <code>...any</code> The data that should be sent to the server</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/client/event/#listen","title":"<code>Listen</code>","text":"<p>Listens for the event to be fired by the server, then runs the provided function.</p> <p>Parameters</p> <ul> <li>listener: <code>(...: any) -&gt; ()</code> The function to call when data is recieved</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/","title":"Interface","text":"<p>References the server event and function constructors</p>"},{"location":"api/server/#functions","title":"Functions","text":""},{"location":"api/server/#event","title":"<code>Event</code>","text":"<p>Creates a new event</p> <p>Parameters</p> <ul> <li> <p>name: <code>string</code>\\ The name of the event to reference or create</p> </li> <li> <p>reliable: <code>boolean</code>\\ Whether the event should be reliable or not. Defaults to true</p> </li> <li> <p>types: <code>{ string }</code>\\ Type validation params to be applied at <code>Listen</code></p> </li> </ul> <p>Returns</p> <ul> <li>Event</li> </ul>"},{"location":"api/server/#async","title":"<code>Async</code>","text":"<p>Creates a new async</p> <p>Parameters</p> <ul> <li> <p>name: <code>string</code>\\ The name of the async to reference or create</p> </li> <li> <p>reliable: <code>boolean</code>\\ Whether the async should be reliable or not. Defaults to true\\ This currently has no effect on asyncs</p> </li> <li> <p>types: <code>{ string }</code>\\ Type validation params to be applied at <code>OnRequest</code></p> </li> </ul> <p>Returns</p> <ul> <li>Async</li> </ul>"},{"location":"api/server/async/","title":"Async","text":"<p>A server-sided async.</p>"},{"location":"api/server/async/#properties","title":"Properties","text":""},{"location":"api/server/async/#reliable","title":"<code>Reliable</code>","text":"<p>Whether or not the async uses a reliable remote event.</p> <ul> <li>boolean</li> </ul>"},{"location":"api/server/async/#methods","title":"Methods","text":""},{"location":"api/server/async/#onrequest","title":"<code>OnRequest</code>","text":"<p>Recieves a request from the client, and runs the callback function which returns some data. Equivalent to RemoteFunction.OnServerInvoke.</p> <p>Parameters</p> <ul> <li>callback: <code>(sender: Player, ...: any) -&gt; (any, ...any)</code> The callback function to run on requesting, must return at least 1 value</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/async/#setmiddleware","title":"<code>SetMiddleware</code>","text":"<p>Allows you to set middleware that runs at specific points in time.</p> <p>Parameters</p> <ul> <li>middleware <code>{ [MiddlewareType]: (...any) -&gt; () }</code> A table of middleware for the event.</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/event/","title":"Event","text":"<p>A server-sided event.</p>"},{"location":"api/server/event/#properties","title":"Properties","text":""},{"location":"api/server/event/#reliable","title":"<code>Reliable</code>","text":"<p>Whether or not the network event uses a reliable remote event.</p> <ul> <li>boolean</li> </ul>"},{"location":"api/server/event/#methods","title":"Methods","text":""},{"location":"api/server/event/#fire","title":"<code>Fire</code>","text":"<p>Fires an event which sends data to the client, equivalent to RemoteEvent:FireClient.</p> <p>Parameters</p> <ul> <li> <p>recipient: <code>Player</code> The player who should recieve the data and/or call</p> </li> <li> <p>data: <code>...any</code> The data that should be sent to the client</p> </li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/event/#firenow","title":"<code>FireNow</code>","text":"<p>Same as <code>Fire</code> but does not batch the call / wait until the next frame.</p> <p>Parameters</p> <ul> <li> <p>recipient: <code>Player</code> The player who should recieve the data and/or call</p> </li> <li> <p>data: <code>...any</code> The data that should be sent to the client</p> </li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/event/#fireall","title":"<code>FireAll</code>","text":"<p>Fires an event which sends data to every client connected to the server, equivalent RemoteEvent:FireAllClients.</p> <p>Parameters</p> <ul> <li>data: <code>...any</code> The data that should be sent to each player</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/event/#fireallexcept","title":"<code>FireAllExcept</code>","text":"<p>Fires an event which sends data to every client connected to the server, except for players defined in the <code>except</code> parameter.</p> <p>Parameters</p> <ul> <li> <p>except: <code>{ Player } | Player</code> The players which the call should not be sent to</p> </li> <li> <p>data: <code>...any</code> The data that should be sent to each player except <code>except</code></p> </li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/event/#firefilter","title":"<code>FireFilter</code>","text":"<p>Fires an event with a filter function, and runs the provided filter on every player in the server.</p> <p>Parameters</p> <ul> <li> <p>filter: <code>(Player) -&gt; boolean</code> The filter to run on each player, return a boolean to indicate that the player meets the threshold</p> </li> <li> <p>data: <code>...any</code> The data that should be sent to each player that meets the threshold for <code>filter</code></p> </li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/event/#listen","title":"<code>Listen</code>","text":"<p>Listens for the event to be fired by the client, then runs the provided function.</p> <p>Parameters</p> <ul> <li>listener: <code>(sender: Player, ...: any) -&gt; ()</code> The function to call when data is recieved</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"api/server/event/#setmiddleware","title":"<code>SetMiddleware</code>","text":"<p>Allows you to set middleware that runs at specific points in time.</p> <p>Parameters</p> <ul> <li>middleware <code>{ [MiddlewareType]: (...any) -&gt; () }</code> A table of middleware for the event.</li> </ul> <p>Returns</p> <ul> <li>void</li> </ul>"},{"location":"guides/","title":"Setup","text":"<p>Setup is relatively easy when using the Net package. It is recommended to be used in conjunction with Lumin Framework, but it can also be used without it.</p> <p>First and foremost, you must <code>require</code> the package on both the server and the client in order to start the networking process without any errors or yielding. The most favorable format is to declare the <code>.Server</code> or <code>.Client</code> interface depending on the current context.</p>"},{"location":"guides/#server","title":"Server","text":"<pre><code>local Net = require(Packages.net).Server\n</code></pre>"},{"location":"guides/#client","title":"Client","text":"<pre><code>local Net = require(Packages.net).Client\n</code></pre>"},{"location":"guides/asyncs/","title":"Asyncs","text":"<p>Asyncs are similar to how RemoteFunctions work and also act as a better way to perform tasks where the server returns data back to the client in a call.</p>"},{"location":"guides/asyncs/#requesting","title":"Requesting","text":"<p>Requesting is done on the client. Calling this method will yield the thread until the value is resolved.</p> <pre><code>local Net = require(Packages.net).Client\nlocal MyAsync = Net.Async(\"MyAsync\")\nlocal Response = MyAsync:Request(\"Hi\")\n\nprint(Response) -- Output: Goodbye\n</code></pre>"},{"location":"guides/asyncs/#listening-to-request","title":"Listening To Request","text":"<p>When listening to a request you must return a value. This is what happens on the server, and if you don't return a value it defeats the purpose of using a async. Use an event instead for this.</p> <pre><code>local Net = require(Packages.net).Client\nlocal MyAsync = Net.Async(\"MyAsync\")\n\nMyAsync:OnRequest(function(sender, data)\n    if data == \"Hi\" then\n        return \"Goodbye\"\n    end\n    return \"Huh?\"\nend)\n</code></pre>"},{"location":"guides/events/","title":"Events","text":"<p>Creating events is arguably the most important part of the entire library, and most useful obviously.</p>"},{"location":"guides/events/#firing","title":"Firing","text":"<p>There are many functions for firing that come with the package already. These include:</p> <ul> <li><code>Fire</code></li> <li><code>FireNow</code></li> <li><code>FireAll</code></li> <li><code>FireExpect</code></li> <li><code>FireFilter</code></li> </ul> <p>The difference between <code>Fire</code> and <code>FireNow</code> is a bit complicated but it will be extremely important to pick the correct when later during development.</p> <p>For one, <code>Fire</code> will batch all of your calls into one single <code>RemoteEvent:Fire</code> call. A result of this is that all of your calls will be recieved by the server or client at the exact same time if called on the same frame. This can lead to issues like race conditions if you have a system that requires precision and relies on an event be called first. <code>FireNow</code> does not batch the calls, and will simply just send the call as soon as possible. This way, the order you sent the packets in will still persist on the other side. The downside of using this is that there is no optimization for this, so use it sparingly and only when needed!</p> <p>A quick example of firing an event is as follows:</p>"},{"location":"guides/events/#client","title":"Client","text":"<pre><code>local Net = require(Packages.net).Client\nlocal MyEvent = Net.Event(\"MyEvent\")\n\nMyEvent:Fire(\"Hello server\")\nMyEvent:FireNow(\"Hello server\")\n</code></pre>"},{"location":"guides/events/#server","title":"Server","text":"<pre><code>local Net = require(Packages.net).Server\nlocal MyEvent = Net.Event(\"MyEvent\")\nlocal Player = game.Players:WaitForChild(\"Someone\")\n\nMyEvent:Fire(Player, \"Hello client\")\nMyEvent:FireNow(Player, \"Hello client\")\n\n-- Server exclusive\nMyEvent:FireAll(\"Hello client\")\nMyEvent:FireExcept(Player, \"Hello client\")\nMyEvent:FireFilter(\"Hello client\", function(player)\n    if player:IsA(\"Player\") then\n        return true\n    else\n        return false\n    end\nend)\n</code></pre>"},{"location":"guides/events/#listening","title":"Listening","text":"<p>Listening will persist the same across both the client and server. The only difference is that there is an additional <code>sender</code> argument on the server callback. Here's an example of how both would work.</p>"},{"location":"guides/events/#client_1","title":"Client","text":"<pre><code>local Net = require(Packages.net).Client\nlocal MyEvent = Net.Event(\"MyEvent\")\n\nMyEvent:Listen(function(arg)\n    print(arg)\nend)\n</code></pre>"},{"location":"guides/events/#server_1","title":"Server","text":"<pre><code>local Net = require(Packages.net).Server\nlocal MyEvent = Net.Event(\"MyEvent\")\n\nMyEvent:Listen(function(sender, arg)\n    print(sender.DisplayName, arg)\nend)\n</code></pre>"},{"location":"guides/middleware/","title":"Middleware","text":"<p>The middleware feature allows you to run functions before or after something happens. For example, the <code>Throttle</code> middleware runs before the internal <code>Listen</code> code is ran and will throttle the event with your code.</p>"},{"location":"guides/middleware/#usage","title":"Usage","text":"<p>There are 2 different types of middleware. These are <code>Throttle</code> and <code>Dropped</code>. Throttle runs before <code>Listen</code> or <code>OnRequest</code>, and <code>Dropped</code> runs when the packet is dropped due to invalid types or NaN.</p> <pre><code>local Net = require(Packages.net).Server\nlocal MyEvent = Net.Event(\"MyEvent\")\n\nMyEvent:SetMiddleware({\n    Throttle = function()\n        if math.random(1, 2) == 1 then\n            print(\"I randomly decided to throttle.\")\n            return false -- Returning false indicates that the event/async should throttle\n        end\n        return true\n    end,\n\n    Dropped = function(sender)\n        print(sender.Name, \"sent the incorrect value from the client!\")\n    end,\n})\n\nMyEvent:Listen(function()\n    print(\"Might print depending on the throttle middleware.\")\nend)\n</code></pre> <p><code>Dropped</code> middleware is explained further in the type validation article.</p>"},{"location":"guides/type-validation/","title":"Type Validation","text":"<p>The type validation feature allows you to strictly specify what types that the server should be getting from the client. For most cases, this ensures safety on both ends of code and also prevents exploiters from just guessing. This can be used to ban/kick them as well.</p>"},{"location":"guides/type-validation/#usage","title":"Usage","text":"<p>To use the type validation feature, you have to declare a table of types in the constructor. The types must also be in the exact order as they are sent; if they are not you might encounter some unexplainable issues if not tested. The example below will kick the sender of the packet if the type is invalid.</p> <pre><code>local Net = require(Packages.net).Server\nlocal MyEvent = Net.Event(\"MyEvent\", true, {\"string\", \"Instance\", \"number\"})\n\nMyEvent:SetMiddleware({\n    Dropped = function(sender, data1, data2, data3)\n        sender:Kick(\"You might be exploiting...\")\n    end\n})\n\nMyEvent:Listen(function(sender, data1, data2, data3)\n    print(sender.DisplayName, data1, data2, data3)\nend)\n</code></pre> <p>For a scenario when the player is kicked;</p> <ul> <li>Data1 - <code>string</code> </li> <li>Data2 - <code>boolean</code> </li> <li>Data3 - <code>number</code> </li> </ul> <p>A warning will be sent in the server output and the packet will be dropped. If you manually set the middleware for this, that will be run instead and a warning will not be displayed.</p>"}]}